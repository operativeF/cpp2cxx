/**
cpp2cxx is an open source software distributed under terms of the
Apache2.0 licence.

Copyrights remain with the original copyright holders.
Use of this material is by permission and/or license.

Copyright [2012] Aditya Kumar, Andrew Sutton, Bjarne Stroustrup
          [2020] Thomas Figueroa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// (c) Copyright
// ALL RIGHTS RESERVED
/**
 *  @file Main.cpp
 *  @brief main file of the project
 *  @version 1.0
 *  @author Aditya Kumar
 *  @brief takes in the config file, generates configuration scheme for
 *  other classes and then calls the class Overseer.
 *  catches all possible unhandled exceptions and displayes them to user
 *  compiles with g++-4.5 or higher,
 *  for compiling pass -std=c++0x to the compiler
 */

#include "cpp2cxx/ConfigScheme.h"
#include "cpp2cxx/ExceptionHandler.h"
#include "cpp2cxx/Overseer.h"
#include "general_utilities/vector_utils.hpp"

//#include "PrintVector.h"

#include <CLI/CLI.hpp>

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>

/**
  * @main

  typical command line argument:
  ./demacrofier configFile.cfg

  ./a.out -i ifile.cpp -o ofile.cpp --global-macros-formatted=gMacros.dat\
   --input-directory=. --output-directory=demac_dir --log-file=log.txt\
   -p __FILE__ -p __LINE__ --backup-directory=backup
  */

/// @todo add object like, fucntion like, open,closed, config etc..
/// to the macro_list_file
int main(int argc, char* argv[])
{
    CLI::App app{"A tool for automating replacement of macros with modern C++ constructs."};
    //std::cout<<"\nName of executable is:"<<argv[0];
    //configuration file --to be loaded instead of the command line parameters
    std::string config_file;
    if(argc < 2)
    {
        config_file = "ConfigFile.cfg";
        //std::cerr<<"usage: config-file\n";
        //return -1;
    }
    else
    {
        config_file = argv[1];
    }

    std::ostream* err_outstream = &std::cerr;
    std::ofstream plog_file;
    //the default file where the demacrofied macros will be listed
    std::ostream* stat_outstream = &std::cerr;
    std::ofstream pstat_file;
    std::ofstream mac_stat_file;

    // std::string help_options;
    // app.add_option("-h,--help", help_options, "Help options.");

    std::vector<std::filesystem::path> input_files;
    app.add_option("-i,--input-files", input_files, "Files to be processed.");

    bool analyze_only{false};
    app.add_option("-a,--analyze", analyze_only, "Perform analysis only; macros will not be translated.");

    bool enable_cleanup{false};
    app.add_option("-c,--clean", enable_cleanup, "Perform cleanup based on already validated refactoring.");

    bool enable_warnings{false};
    app.add_option("-w,--warn", enable_warnings, "Display warning messages during processing.");

    bool enable_mul_defs{false};
    app.add_option("-m,--mul-def", enable_mul_defs, "Allow demacrofication when multiple definitions of macros are found.");

    std::vector<std::filesystem::path> search_paths;
    app.add_option("-sp,--search-paths", search_paths, "Paths where the clang front end will search for header files.");

    std::filesystem::path macro_list_file;
    app.add_option("--macro-stat-file", macro_list_file, "File showing all the statistics of the macros processed.");

    std::filesystem::path log_file;
    app.add_option("-l,--log", log_file, "File where the error and warnings will be written.");

    std::vector<std::filesystem::path> output_files;
    app.add_option("-o,--output-files", output_files, "Resulting file outputs.");

    std::filesystem::path input_directory;
    app.add_option("--input-dir", input_directory, "Input directory for processing. Defaults to current directory.")->default_val(".");

    std::filesystem::path output_directory;
    app.add_option("--output-dir", output_directory, "Output directory for files.")
        ->default_val("dm_dir")
        ->check(CLI::ExistingDirectory); // @TODO: If the directory isn't there, make it.
    
    std::filesystem::path stat_file;
    app.add_option("-s,--stat-file", stat_file, "File where the list of macros processed will be logged.");

    std::filesystem::path validator_file;
    app.add_option("-v,--validator-file", validator_file, "File which was generated by the validator script. It should contain all the macro-switches which needs to be finally replaced.")
        ->default_val("Defined.h");
    
    std::filesystem::path backup_directory;
    app.add_option("-b,--backup-dir", backup_directory, "The directory where source files should be copied for backup, this directory will be deleted later.");

    std::filesystem::path cleanup_directory;
    app.add_option("--clean-dir", cleanup_directory, "The directory where the demacrofied files will be placed.")
        ->default_val("cleanup");

    std::vector<std::string> macros_preventing_demacrofication;
    app.add_option("-p,--ignore-macros", macros_preventing_demacrofication, "Predefined macros that, when found in the body of other macros, prevent demacrofication.");

    std::string global_macros_formatted;
    app.add_option("--global-formatted", global_macros_formatted, "File containing global macros formatted like:\n<Macro-id>\n<Replacement-list>");

    std::string global_macros_raw;
    app.add_option("--global-raw", global_macros_raw, "File containing global macros.");
    
    std::string demac_granularity;
    app.add_option("--gran", demac_granularity, "Demacrofy either per file or per macro.")
        ->default_str("file");

    try
    {
        app.parse(argc, argv);
    }
    catch(const CLI::ParseError& e)
    {
        return app.exit(e);
    }


    ///@todo if output file is null then the output will be printed on the screen
    ///check this

    // "make-command",
    // po::value<std::string>(&make_command)->default_value("make"),
    // "the command which needs to be invoked in the shell to compile the project");

        //po::positional_options_description p;
        //p.add("input-file", -1);

    std::ifstream cfg(config_file, std::ios_base::in);

    if(!cfg.is_open())
    {
        std::cerr << "can not open config file: " << config_file << "\n";
        return -1;
    }

    


    if(app.count("help"))
    {
        std::cout << "usage: <Executable> [options]\natleast input file is a must.\n";
        std::cout << "If no output file is specified then the output "
                    << "will be redirected to the standard output\n";
        //std::cout << config_file_options;
        return 0;
    }

    if(app.count("analyze"))
    {
        if(analyze_only)
        {
            std::cout << "processing the macros for just analysis\n"
                        << "-- if you want to translate, set option no-translate to false\n";
        }
        else
        {
            std::cout
                    << "processing and translating the macros\n"
                    << "-- if you don\'t want to translate, set option no-translate to true\n";
        }
    }

    if(app.count("input-file"))
    {

        /// @todo check if prefixing the output directory path to the output
        /// file name is useful or not
        std::for_each(input_files.begin(), input_files.end(),
                [input_directory](std::filesystem::path& input_file) {
                    input_file = input_directory / input_file;
                });
        std::cout << "input files are:\n" << input_files << "\n";
    }
    else
    {
        std::cerr << "error: no input file specified. exiting...\n";
        //std::cerr << config_file_options;
        return -1;
    }

    //during the cleanup process the output files are taken corresponding
    //to the cleanup files
    if(app.count("output-file"))
    {
        //if output files are given then total number of output files
        //should be equal to the total number of input files
        if(!input_files.empty() && (input_files.size() != output_files.size()))
        {
            std::cerr << "Number of input files and output files are not equal";
            return -1;
        }

            /*
    if(cleanup)
        output_directory = cleanup_directory;
    */
        /// @todo check if prefixing the output directory path to the output
        /// file name is useful or not
        std::for_each(output_files.begin(), output_files.end(),
                [output_directory](std::filesystem::path& output_file) {
                    output_file = output_directory / output_file;
                });

        //std::cout << "Output files are: "
        //          << vm["output-file"].as<std::vector<std::string> >() << "\n";
        std::cout << "output files are:\n" << output_files << "\n";
    }
    else
    {
        std::cout << "warning: no output filename specified.";
        std::cout << "output shall be redirected to the standard output\n";
        output_files.resize(input_files.size());
    }

    if(app.count("search-path"))
    {
        std::cout << "search paths:\n" << search_paths;
    }
    else
    {
        std::cerr << "no search path provided the tool will search only"
                    << " in the present directory\n";
    }

    if(app.count("macro-stat-file"))
    {
        macro_list_file = output_directory / macro_list_file;
        mac_stat_file.open(macro_list_file, std::ios_base::out);
        if(!mac_stat_file.is_open())
        {
            std::cerr << "file to list macros: " << macro_list_file << " could not be opened, "
                        << "redirecting the list to std::cerr";
        }
    }

    if(app.count("log-file"))
    {
        log_file = output_directory / log_file;
        plog_file.open(log_file, std::ios_base::out);
        if(plog_file.is_open())
        {
            err_outstream = &plog_file;
        }
        else
        {
            std::cerr << "log-file: " << log_file << " could not be opened, "
                        << "redirecting the errors/warnings to std:cerr";
        }
    }

    if(app.count("stat-file"))
    {
        stat_file = output_directory / stat_file;
        pstat_file.open(stat_file, std::ios_base::out);
        if(pstat_file.is_open())
        {
            stat_outstream = &pstat_file;
        }
        else
        {
            std::cerr << "stat-file: " << stat_file << " could not be opened, "
                        << "redirecting the errors/warnings to std::cerr";
        }
    }

    if(app.count("validator-file"))
    {
        // if reading of validator_file is successful
        std::cout << "the validator-file is: " << validator_file << "\n";
    }

    if(app.count("global-macros-raw"))
    {
        //global_macros_raw = vm["global-macros-raw"].as<std::string>();
        std::cout << "file containing global macro is: " << global_macros_raw
                    << "\nthe global macros after being parsed will be kept"
                    << "in file gMacros.dat in a formatted form, this file can be"
                    << "used later to avoid parsing of global macros all the time"
                    << "when no new global macros are added.\n";
    }

    if(app.count("global-macros-formatted"))
    {
        //global_macros_formatted = vm["global-macros-formatted"].as<std::string>();
        std::cout << "file containing formatted global macro is: " << global_macros_formatted
                    << "\n";
    }

#ifndef BUILD_NEW_MACRO_LIST
        else
        {
            std::cerr << "when BUILD_NEW_MACRO_LIST is not defined,"
                      << "a file containing global formatted macros"
                      << "should be specified. exiting...\n";
            //std::cerr << config_file_options;
            return -1;
        }
#endif

    if(app.count("input-directory"))
    {
        //input_directory = vm["input-directory"].as<std::string>();
        std::cout << "files to be taken from directory: " << input_directory << "\n";
    }

    if(app.count("output-directory"))
    {
        //output_directory = vm["output-directory"].as<std::string>();
        std::cout << "files to be put to directory: " << output_directory << "\n";
    }

    // if(app.count("verbose"))
    // {
    //     std::cout << "verbosity enabled.  Level is " << app["verbose"].as<int>() << "\n";
    // }

    if(app.count("ignore-macros"))
    {
        std::cout << "macros to prevent demacrofication are:\n"
                    << macros_preventing_demacrofication << "\n";
    }

    if(app.count("backup-directory"))
    {
        std::cout << "backup directory: " << backup_directory << "\n";
    }

    if(app.count("cleanup-directory"))
    {
        std::cout << "cleanup directory: " << cleanup_directory << "\n";
    }

    // if(app.count("make-command"))
    // {
    //     std::cout << "make command: " << make_command << "\n";
    // }
    // else
    // {
    //     std::cout << "no make command/script provided. "
    //                 << "default command `make` will be used\n";
    // }

    if(app.count("demacrofication-granularity"))
    {
        if((demac_granularity != "OneFileAtATime")
                && (demac_granularity != "OneMacroAtATime"))
        {
            // std::cerr << "error: invalid value for demacrofication_granularity\n"
            //             << config_file_options;
            return -1;
        }
        std::cout << "demacrofying: " << demac_granularity << "\n";
    }

    ConfigScheme pConfigScheme; // = new ConfigScheme();

    //set file manager scheme should be called before
    //the set demcrofication scheme because the demacrofication scheme
    //uses the names of files (e.g. validator_file)
    pConfigScheme.SetFileManagerScheme(input_files, output_files, search_paths, input_directory,
            output_directory, backup_directory, cleanup_directory, validator_file,
            err_outstream, stat_outstream, &mac_stat_file);
    pConfigScheme.SetDemacroficationScheme(
            demac_granularity, macros_preventing_demacrofication, enable_warnings,
            global_macros_raw, global_macros_formatted, enable_mul_defs,
            false //passing false until a separate cleanup tool is developed
    );

    // @TODO: Setup a different way to do this.
    pConfigScheme.SetBuildScheme("make");

    //step1. load the Overseer class with the configuration scheme
    auto pOverseer = Overseer(pConfigScheme);
    //step2. start processing
    pOverseer.StartProcessing(!analyze_only);
    std::cout << "\ndone...\n";


    ///@todo when global_macros_formatted is provided use that one
    plog_file.close();
    pstat_file.close();
    //    delete pConfigScheme;

    return 0;
}
